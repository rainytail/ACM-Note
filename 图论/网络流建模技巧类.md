## 拆点

网络流一般是在二分图的基础上建立，如果已经想到用网络流解决但是没有找到二分图，可以试着使用拆点。
在二分图中使用拆点，一般有如下情况：

1. 对点集本身可以根据类别来划分出两类点，如黑白染色，划分出黑点和白点，在这两类点中作二分图
2. 对于某一个点，本身有两种性质，比如：一天有起始点和结束点、有向图的点，既可以作弧头，也可以作弧尾
3. 点遍历的次数是有限的，比如每个点只能用一次，就拆成两点，连一条容量为 $1$ 的边
4. 对点进行操作，比如给某个点设置一个障碍物

有时候可能有好几种拆点的方式，比如 $2$ 和 $3$ ，要注意是否都支持题目的要求。

## 关于重边（费用流）
如果一个边可以被重复经过，但是只有有限次会产生贡献，那么连接一条容量为贡献次数的边，再连接一条容量 INF 费用 0 的边即可。（注意还有反向边）

如果一个点可以被重复经过，也只有有限次会产生贡献，可以使用拆点，然后按上述规则建边。

## 转化为最小割

典型的是这一题：https://www.luogu.com.cn/problem/CF311E

如果有代价和价值边，即一个是产生贡献，一个是消费贡献，我们可以使用最小割模型。

把贡献边和代价边关联，那么如果选择贡献边，就需要割掉所有代价，如果不选择贡献边，需要割掉贡献。

这样求出来的最小割就是损失掉的贡献了。（假设全部产生贡献的前提下）

## 多次跑网络流
多次跑网络流，有以下三种可能：
1. 每次建立新图，这样每次跑网络流是互相不影响的，这样的作法是每次直接把原图清空。
2. 在原图的基础上增加边，这样作**不能跑残余网络**，因为增加边就代表图的某些性质会发生变化，一种做法是，每次在原图上增加边，跑网络流的时候，把原图赋值到一张新图上，在新图上跑网络流。
3. 在原图的基础上增加点，可以直接在残余网络上跑网络流，比如这题 https://loj.ac/p/6003
   需要注意的是：在残余网络上跑出来的最大流是在原来的最大流上**增加的流**，它本质就是增加增广路。

## 求方案
在求出最大流后，残余网络中本身存留着流的方案(此时已经没有增广路，即 $s$ 和 $t$ 不连通)，对于边 $u \to v$ ，如果建图时容量和残余网络中容量发生变化，则表示方案中有 $u \to v$ 的选择。
在求方案时，可以在 dfs 时记录前驱，然后从 $t$ 开始遍历到 $s$ 。
```c++
int pre[N]; // pre(i)表示到达i点的增广路，连接i的边编号

// 求路径点
vector<int> ans;
for (int i = t; i != s; i = e[pre[i]^1]) {
	ans.push_back(i);
} ans.push_back(s);

reverse(ans.begin(), ans.end());
```