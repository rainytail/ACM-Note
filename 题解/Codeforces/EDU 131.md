### C. Schedule Management
#### 题意
给定 $n$ 个员工和 $m$ 项工作，每项工作都有一个员工擅长，员工对擅长的工作需要消耗 1 小时，不擅长的工作需要消耗 2 小时。
问完成 $m$ 项工作最少需要多少小时。
#### 分析
先考虑让所有员工做擅长的工作，得到 f 数组，其中 $f[i]$ 表示员工 i 需要消耗的时间，$max(f)$ 即完成 $m$ 项工作最少需要的时间。
考虑转移，对于一次操作：$f[i]-1, f[j]+2$ ，问若干次操作后最大值的最小值。
二分答案即可。
#### Code
```c++
/* さあ，Games始めましょうか */
#include <bits/stdc++.h>
#define rep(i, x, y) for (int i = x; i <= y; i ++ )
#define per(i, x, y) for (int i = x; i >= y; i -- )
#define forr(x, s) for (auto x : s)
#define all(a) begin(a), end(a)
#define rall(a) rbegin(a), rend(a)
#define pb push_back
#define int long long
using namespace std; using T = pair<int, int>; using ll = long long;
const int N = 200010, M = 400010, mod = 998244353, INF = 0x3f3f3f3f;

int n, m, f[N];

bool check (int x) {
    int cnt1 = 0, cnt2 = 0; // 大于的和小于的
    for (int i = 1; i <= n; i ++ ) {
        if (f[i] > x) cnt1 += f[i] - x;
        else if (f[i] < x) {
            cnt1 -= (x - f[i]) / 2;
        }
    }
    return cnt1 <= 0;
}

void solve ()
{
    cin >> n >> m;
    fill(f + 1, f + n + 1, 0);
    for (int i = 1; i <= m; i ++ ) {
        int x; cin >> x;
        ++ f[x];
    }
    int l = 1, r = 1e9 + 10;
    while(l < r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << endl;
}

signed main ()
{
    cout.tie(0)->sync_with_stdio(0);
    int _; for (cin >> _; _ -- ; )
        solve();
}
```

### D. Permutation Restoration
#### 题意
给定长度为 $n$ 的数组 $b$ ，有：$b[i] = \lfloor \dfrac i {a[i]} \rfloor$ ，求数组 $a$ 。
#### 分析
对于 $a[i]$ ，存在范围，将每个范围求出来，则问题转换为：
给定若干个区间，将 $1 \sim n$ 的数字放入完，求每个区间所放的数字。
对区间右端点排序，从前往后遍历区间，求出最左边没有被选中的数字，就是这个区间所选的数字。
使用并查集维护：当前数字的下一个没有被选中的数字。
#### Code
```c++
#include <bits/stdc++.h>
using namespace std;

struct T { int id, l, r; };

const int N = 500010;
int n, p[N], a[N];
T D[N];

int find (int x) {
    return x == p[x] ? x : p[x] = find(p[x]);
}

void solve () {
    cin >> n;
    for (int i = 1; i <= n; i ++ ) {
        int x; cin >> x;
        auto &[id, l, r] = D[i];
        id = i;
        if (x == 0) {
            l = i + 1, r = n;
        } else {
            l = i / (x + 1) + 1, r = i / x;
        }
    }
    sort(D + 1, D + n + 1, [&](T a, T b) {
        if (a.r != b.r) return a.r < b.r;
        return a.l < b.l;
    });
    iota(p + 1, p + n + 1, 1);
    for (int i = 1; i <= n; i ++ ) {
        auto [id, l, r] = D[i];
        a[id] = find(l);
        p[find(l)] = find(l) + 1;
    }
    for (int i = 1; i <= n; i ++ ) cout << a[i] << " \n"[i==n];
}

int main () {
    int t; cin >> t; while(t -- ) {
        solve();
    }
    return 0;
}
```