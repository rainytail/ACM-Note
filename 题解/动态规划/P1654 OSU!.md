## 题意
有 $n$ 次操作，每次操作只有成功和失败两种结果，给出每次成功的概率 $p$ ，用 $01$ 序列表示最后的结果，$1$ 表示成功，则对于每极长连续 $1$ 的子串，贡献 $X^3$ ($X$ 为长度)，问贡献的期望值。
$1 \le n \le 10^5$ 。
比如 0001101 ，贡献为 $2^3 + 1^3 = 9$ 。

## 分析
#DP #期望 #概率

考虑对于 $X$ ，后面再加上 $1$ 的期望。
由于 $(X + 1)^3 = X^3 + 3 \times X^2 + 3 \times X + 1$ ，所以：
枚举到某一个位置时，前面连续 $X$ 个 $1$ ，再加上当前位的 $1$ 后，多出贡献 $3 \times X^2 + 3 \times X + 1$ 。
维护 $x1$ 表示 $X$ 的期望，$x2$ 表示 $X^2$ 的期望。

解释为什么 $x1[i] = (x1[i-1] + 1) \times p[i]$ 。
因为 $x1[i]$ 表示的是前 $i$ 个操作，**最后**连续的 $1$ 的期望长度。
对于前面 $i-1$ 个操作，第 $i$ 个只有加上 $1$ ，才能延续这个连续的 $1$ 。

比如，假设 $p[i] = 0.1$ ，那么有 $1/0.1 = 10$ 个样本，其中只有 $1$ 个样本是 $1$ ，那么这个样本 $x[i] = x[i-1] + 1$ ，但是其他的都是 $x[i] = 0$ ，因此期望是 $x[i] = (x[i-1] + 1) \times p[i]$ 。

## Code
```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 200010;

double p[N], x1[N], x2[N], ans[N];

int main ()
{
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) {
        cin >> p[i];
        x1[i] = (x1[i-1] + 1) * p[i];
        x2[i] = (x2[i-1] + 2 * x1[i-1] + 1) * p[i];
        ans[i] = ans[i-1] + (3 * x2[i-1] + 3 * x1[i-1] + 1) * p[i];
    }
    printf("%.1f\n", ans[n]);
    return 0;
}
```